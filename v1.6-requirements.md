# Version 1.6 Requirements

## Objectives

Version 1.6 focuses on **practical patterns and proven optimizations** based on real production feedback from v1.4 and v1.5 deployments. This release adds commonly requested features while maintaining simplicity and Go-idiomatic design.

### Primary Goals

1. **Useful Patterns**: Support practical event processing patterns that solve real production problems.

2. **Better Testing**: Improve testing utilities and debugging capabilities for users.

3. **Framework Integration**: Provide simple adapters for popular Go frameworks.

4. **Production Hardening**: Add features validated by actual production use cases.

### Target Outcomes

- **Pattern Library**: Simple, composable signal patterns (filtering, mapping, batching)
- **Testing Utilities**: Test helpers, recording/replay, assertions
- **Framework Adapters**: HTTP middleware, common framework bridges
- **Production Ready**: All features validated in real deployments

### Alignment with Long-term Vision

This release makes the signals library **easier to use in production** while staying focused on its core mission: fast, reliable in-process event signaling in Go.

---

## Functional Requirements

### 1. Signal Composition Patterns
**Priority:** MEDIUM
**Status:** Design Phase

Simple functional patterns for signal processing.

**Requirements:**

#### Filtering
```go
// Only emit if condition met
filtered := sig.Filter(func(ctx context.Context, data Event) bool {
    return data.Priority > 5
})
```

#### Mapping
```go
// Transform payload before emission
mapped := sig.Map(func(ctx context.Context, in Event) Output {
    return transformEvent(in)
})
```

#### Batching
```go
// Batch multiple events
batched := sig.Batch(100, 1*time.Second) // 100 events or 1 sec
```

#### Merging (Maybe)
```go
// Combine multiple signals
merged := signals.Merge(sig1, sig2, sig3)
```

**Use Cases:**
- Filter events by criteria
- Transform payloads
- Batch processing
- Multi-source aggregation

**Success Criteria:**
- Clean, composable API
- Zero allocations when possible
- Type-safe transformations
- Clear documentation with examples
- Benchmark suite showing overhead

---

### 2. Testing Utilities
**Priority:** HIGH
**Status:** Design Phase

Make testing signal-based code easier.

**Requirements:**

#### Signal Recording
```go
// Record events for testing
recorder := signals.NewRecorder[Event]()
sig.AddListener(recorder.Record, "recorder")

// In tests
events := recorder.Events()
assert.Len(t, events, 3)
```

#### Signal Assertions
```go
// Testing helper
mock := signals.NewMock[Event](t)
sig.AddListener(mock.Listener(), "test")

sig.Emit(ctx, event)

mock.AssertCalled(t, 1)
mock.AssertCalledWith(t, func(e Event) bool {
    return e.Type == "expected"
})
```

#### Signal Spies
```go
// Count calls without side effects
spy := signals.NewSpy[Event]()
sig.AddListener(spy.Listener(), "spy")

// Check later
fmt.Printf("Called %d times\n", spy.CallCount())
```

**Success Criteria:**
- Works with standard `testing` package
- Compatible with testify assertions
- Simple, minimal API
- Well-documented examples

---

### 3. Listener Groups
**Priority:** LOW
**Status:** Design Phase

Organize listeners into groups for bulk operations.

**Requirements:**
```go
// Add listeners to a group
sig.AddToGroup("analytics", listener1, "key1")
sig.AddToGroup("analytics", listener2, "key2")

// Remove entire group
sig.RemoveGroup("analytics")

// Enable/disable group (maybe)
sig.SetGroupEnabled("analytics", false)
```

**Use Cases:**
- Feature flags (enable/disable groups)
- Plugin systems (add/remove plugin listeners)
- Testing (mock out listener groups)

**Success Criteria:**
- Simple API, no complex group hierarchies
- Works with both sync and async signals
- Clear documentation

---

### 4. Signal Middleware
**Priority:** MEDIUM
**Status:** Design Phase

Middleware pattern for cross-cutting concerns.

**Requirements:**
```go
// Add middleware (wraps all listeners)
sig.Use(loggingMiddleware)
sig.Use(metricsMiddleware)

// Middleware signature
type Middleware[T any] func(
    next SignalListener[T],
) SignalListener[T]

// Example middleware
func LoggingMiddleware[T any](next signals.Listener[T]) signals.Listener[T] {
    return func(ctx context.Context, data T) error {
        log.Printf("Signal emitted: %v", data)
        return next(ctx, data)
    }
}
```

**Use Cases:**
- Logging all signal emissions
- Timing all listener executions
- Error handling/recovery
- Metrics collection

**Success Criteria:**
- Familiar middleware pattern (like http.Handler)
- Works with both sync and async
- <5% performance overhead
- Examples for common use cases

---

### 5. HTTP Integration Helpers
**Priority:** LOW
**Status:** Idea Phase

Helpers for common web patterns.

**Requirements:**
```go
// HTTP middleware that emits request signals
handler := signals.HTTPMiddleware(requestSignal, yourHandler)

// Server-Sent Events helper
http.HandleFunc("/events", signals.SSEHandler(sig))
```

**Supported:**
- Standard library `net/http`
- Optional: Chi, Gorilla Mux adapters

**Success Criteria:**
- Simple wrappers, not a framework
- Works with standard library
- Clear examples

---

## Non-Functional Requirements

### Performance

#### Target Performance
- **Latency**: p99 < 500ns for single listener (realistic target)
- **Throughput**: 1M+ emits/sec on typical hardware (8-16 cores)
- **Overhead**: Composition patterns add <10% overhead
- **Allocations**: Zero allocations in fast paths

#### Benchmarking
- Benchmark suite for all new features
- Regression detection (<10% degradation fails build)
- Real-world workload examples
- Performance documented for each feature

**Realistic Approach:**
- Focus on common cases, not extreme edge cases
- Measure on typical hardware (not 64-core servers)
- Validate with actual production workloads
- Don't optimize prematurely

---

### Testing & Quality

#### Test Coverage
- **Unit tests**: >95% line coverage
- **Integration tests**: All patterns tested end-to-end
- **Property-based tests**: For composition patterns
- **Race detector**: All tests pass with `-race`
- **Fuzz testing**: For parsers/validators (if any)

#### Quality Gates
- All tests pass (unit, integration, race, property-based)
- Benchmarks show acceptable performance
- Documentation review complete
- At least 2 reviewers approve
- Tested on Linux, macOS, Windows

**Realistic Approach:**
- Standard Go testing practices
- No exotic tools or techniques
- Focus on real bugs, not metrics
- Manual testing for complex scenarios

---

### Compatibility

#### API Compatibility
- **100% backward compatibility** with v1.5.x
- **Opt-in features**: All new features disabled by default
- **Deprecation**: 6-month notice for any API changes (unlikely)
- **Versioning**: Strict semantic versioning

#### Platform Support
- **Go versions**: 1.21+ (leverage latest features)
- **Operating systems**: Linux, macOS, Windows
- **Architectures**: amd64, arm64

**No Special Platform Optimizations:**
- No NUMA tuning
- No platform-specific assembly
- Works the same everywhere

---

### Documentation

#### User Documentation
- **Getting Started**: Updated with new patterns
- **API Reference**: Complete examples for all APIs
- **Patterns Guide**: Common composition patterns
- **Migration Guide**: From v1.5 to v1.6
- **Testing Guide**: How to test signal-based code

#### Developer Documentation
- **Design Decisions**: Why features work this way
- **Performance**: Benchmarks and optimization tips
- **Contributing**: How to contribute patterns
- **Architecture**: How patterns are implemented

**Realistic Approach:**
- Clear, concise documentation
- Runnable examples (Go Playground links)
- Real-world use cases
- No marketing hype

---

## Out of Scope for v1.6

The following items are explicitly out of scope:

### Not Planned
- **Formal verification**: TLA+, model checking - too expensive for marginal benefit
- **NUMA optimization**: Platform-specific, complex, limited use case
- **Distributed signals**: Separate package if ever needed, not core library
- **Visual debuggers/IDE plugins**: Out of scope for a library
- **Circuit breakers**: Application concern, not library concern
- **Listener prioritization**: Added complexity, use separate signals instead
- **Advanced backpressure**: v1.5 queue limits are sufficient
- **10M+ emit/sec targets**: Unrealistic without validation

### Deferred to Future (if ever)
- **Code generation tools**: Users can write simple code themselves
- **Governance model**: Premature for current adoption level
- **Certification/compliance**: No identified need
- **Plugin system**: YAGNI - current API is extensible enough

---

## Migration Path from v1.5.x

All v1.5.x code will continue to work without changes. New features are opt-in:

```go
// Existing v1.5 code - no changes needed
sig := signals.NewSignal[Event]()
sig.AddListener(listener, "key")
sig.Emit(ctx, event)

// New v1.6 features - opt-in

// Composition patterns
filtered := sig.Filter(func(ctx context.Context, e Event) bool {
    return e.IsValid()
})

// Testing utilities
mock := signals.NewMock[Event](t)
sig.AddListener(mock.Listener(), "test")
mock.AssertCalled(t, 1)

// Middleware
sig.Use(loggingMiddleware)

// Listener groups
sig.AddToGroup("analytics", listener, "key")
sig.RemoveGroup("analytics")
```

---

## Success Metrics

### Technical Metrics

#### Performance (Realistic)
- **Latency**: p99 < 500ns (single listener, typical hardware)
- **Throughput**: 1M+ emits/sec on 8-16 core systems
- **Composition overhead**: <10% for typical chains
- **Zero allocations**: Maintained in fast paths

#### Quality
- **Test coverage**: >95% line coverage
- **Race detector**: Zero races detected
- **Bug density**: <1 bug per 1000 lines
- **User satisfaction**: >85% positive feedback

### Adoption Metrics (6-month targets)

#### Production Usage
- **Deployments**: 5+ production deployments using v1.6 features
- **GitHub stars**: 300+ stars
- **Contributors**: 15+ contributors
- **Downloads**: Tracked via pkg.go.dev

#### Community
- **Issues resolved**: >90% of issues addressed within 30 days
- **Documentation feedback**: Clear and helpful (user surveys)
- **Stack Overflow**: Active Q&A presence

### Quality Gates

#### Pre-Release
- ✅ All tests pass (unit, integration, race, property-based)
- ✅ Benchmarks show ≤10% regression
- ✅ Documentation complete and reviewed
- ✅ At least 2 production beta deployments successful
- ✅ Migration guide validated by users

#### Post-Release (90 days)
- ✅ Zero critical bugs
- ✅ <3 high-severity bugs
- ✅ >85% positive feedback
- ✅ Features used in production

---

## Dependencies on v1.5

v1.6 builds upon v1.5 features:

- **Worker pools** (v1.5) enable better middleware support
- **Metrics** (v1.5) help debug composition chains
- **Configurable pools** (v1.5) work with new patterns

**Recommendation**: Use v1.5 for at least 3-6 months before upgrading to v1.6.

---

## Timeline (Tentative)

- **Q1 2026**: Design and prototype composition patterns
- **Q2 2026**: Implement testing utilities and middleware
- **Q3 2026**: Framework integrations and documentation
- **Q4 2026**: Beta release and production validation
- **Q1 2027**: v1.6.0 stable release (if all goes well)

**Note**: Timeline depends on:
- v1.5 adoption and feedback
- Real production use cases validating features
- Community contributions
- Maintainer availability

**Philosophy**: Ship when ready, not on a schedule. Quality over deadlines.
