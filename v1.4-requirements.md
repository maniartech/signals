# Version 1.4 Requirements

## Objectives

Version 1.4 represents a **enterprise-grade release** elevating the signals library to production-ready standards for Fortune 500 companies, financial institutions, and mission-critical systems. This release focuses on eliminating performance bottlenecks, providing enterprise observability, and meeting strict reliability requirements demanded by regulated industries.

### Primary Goals

1. **Zero-Contention Architecture**: Replace mutex-based listener management with lock-free copy-on-write approach to achieve predictable sub-microsecond latency and linear scalability required by high-frequency trading, real-time analytics, and low-latency microservices.

2. **Application-Level Observability**: Provide lightweight metrics and introspection capabilities enabling developers to monitor signal behavior within their applications. Support integration with standard observability tools (Prometheus, OpenTelemetry) for application-level monitoring without adding distributed tracing overhead.

3. **Operational Excellence**: Improve API ergonomics, configurability, and introspection capabilities to reduce operational overhead, enable self-service debugging, and support enterprise governance requirements.

4. **High-Assurance Quality**: Implement property-based and fuzz testing to achieve the level of correctness verification expected in financial services, healthcare, and other regulated industries.

5. **Enterprise Support Readiness**: Maintain backward compatibility, provide comprehensive migration guides, and establish documentation standards that support enterprise adoption and long-term maintenance.

### Target Outcomes

#### Performance SLAs
- **Latency**: p99 < 10μs for signal emission (down from ~50μs with lock contention)
- **Throughput**: 1M+ emissions/sec on standard hardware (8-core CPU)
- **Scalability**: Linear performance scaling up to 10,000 concurrent emitters
- **Memory**: Zero allocation in fast path (single listener, no keys)
- **GC Pressure**: <100 allocations/sec under typical load

#### Observability Requirements
- **Metrics Overhead**: <1% CPU overhead when metrics enabled
- **Integration**: Optional Prometheus exporter for application-level metrics
- **Introspection**: Runtime APIs to inspect listener state and signal activity
- **Local Tracing**: Support for OpenTelemetry spans within the application process
- **Debug Visibility**: Programmatic access to signal statistics and health

#### Reliability Standards
- **Test Coverage**: >95% code coverage maintained
- **Concurrency Safety**: Zero data races under all conditions (race detector + property tests)
- **Fault Isolation**: Listener panics/errors never affect other listeners or system stability
- **Resource Safety**: Guaranteed cleanup of all resources (goroutines, memory, handles)
- **API Stability**: Zero breaking changes, semantic versioning strictly followed

#### Enterprise Adoption Metrics
- **Production Deployments**: 5+ enterprise production deployments within 6 months
- **Scale Validation**: Tested at 100,000+ signals/sec in production environments
- **Industry Validation**: Adoption in at least 2 regulated industries (finance, healthcare, etc.)
- **Community Growth**: 100+ GitHub stars, active issue resolution (<48hr response)

### Alignment with Enterprise Requirements

This release addresses critical enterprise needs:

- **Compliance**: Metrics and introspection for application-level auditing
- **Performance**: Predictable low-latency enabling high-performance applications
- **TCO Reduction**: Lower operational costs through better observability and resource efficiency
- **Risk Mitigation**: Enhanced testing and fault isolation reducing bugs in production
- **Vendor Independence**: No external dependencies, enterprise-friendly Apache 2.0 license

### Roadmap Alignment

This release addresses items 1, 2, 6, 7, and 8 from the enhancements roadmap, establishing a foundation for future enterprise features:
- **v1.5**: Dynamic pool scaling, advanced metrics aggregation, multi-datacenter support
- **v1.6+**: Formal verification, enterprise support contracts, certified integrations

---

## Functional Requirements

### 1. Lock-Free Listener Management
**Priority:** HIGH
**Status:** Not Implemented (0%)

Implement copy-on-write listener management using `atomic.Value` to eliminate lock contention during signal emission.

**Requirements:**
- Replace `sync.RWMutex` with `atomic.Value` for listener storage
- Implement copy-on-write semantics for Add/Remove operations
- Ensure lock-free read path for Emit operations
- Maintain backward compatibility with existing API
- Add comprehensive race condition tests
- Benchmark against current mutex-based implementation

**Success Criteria:**
- Reduced latency in high-concurrency scenarios (>1000 concurrent emitters)
- Zero lock contention during emission
- Pass all existing tests plus new race condition tests
- Performance improvement of 20%+ in concurrent benchmark scenarios

---

### 2. Configurable Worker Pool
**Priority:** MEDIUM
**Status:** Partially Implemented (40%)

Extend the existing worker pool implementation to support user configuration and dynamic scaling.

**Requirements:**
- Add `SignalOptions.WorkerPoolSize` configuration option
- Support per-signal and global pool size configuration
- Implement dynamic pool scaling based on load (optional)
- Add pool utilization metrics (emit rate, queue depth, worker idle time)
- Provide API to query current pool size and utilization
- Document pool sizing guidelines and best practices

**Success Criteria:**
- Users can configure pool size at signal creation
- Pool automatically scales under load (if dynamic scaling enabled)
- Metrics available for monitoring pool health
- Performance testing shows optimal resource usage

---

### 3. API Ergonomics Enhancements
**Priority:** MEDIUM
**Status:** Partially Implemented (70%)

Improve usability with one-time listeners, error-aware listeners for all signal types, and listener introspection using concise, Go-idiomatic API naming.

**Requirements:**

#### Core API Enhancements
- **Add `AddListenerWithErr` to base `Signal` interface**: Currently only available on `SyncSignal`, should be available for both sync and async signals
  - AsyncSignal behavior: Errors logged/captured but don't block (fire-and-forget with error tracking)
  - SyncSignal behavior: Errors propagated through `TryEmit()` (existing behavior maintained)
  - Enables consistent error handling patterns across all signal types

- Implement `AddOnce()` / `AddOnceWithKey()` for auto-removal after first emit
- Add `Keys() []string` method to query all registered listener keys
- Add `HasKey(key string) bool` to check listener key existence
- Keep existing `Len() int` for listener count (already implemented)
- Add `Metadata(key string) *ListenerMetadata` to retrieve listener information
- Document all new APIs with examples

**API Design Principles:**
- **Concise names**: `Keys()` not `ListenerKeys()` (context is clear)
- **Consistency**: Match Go stdlib patterns (e.g., `sync.Map.Range`, `Len()`)
- **Composability**: Methods work together for common workflows
- **Performance**: `Keys()` returns slice copy (safe concurrent access)
- **Unified interface**: Error-aware listeners available on all signal types

**Detailed API Specification:**

```go
// Base Signal interface enhancements
type Signal[T any] interface {
    // ... existing methods ...

    // NEW: Error-aware listener support (promoted from SyncSignal to base interface)
    AddListenerWithErr(listener func(context.Context, T) error, key ...string) int

    // NEW: One-time listeners (auto-remove after first emit)
    AddOnce(listener Listener[T]) int
    AddOnceWithKey(listener Listener[T], key string) int

    // NEW: One-time error-aware listeners
    AddOnceWithErr(listener func(context.Context, T) error) int
    AddOnceWithErrAndKey(listener func(context.Context, T) error, key string) int

    // NEW: Listener introspection
    Keys() []string                           // Returns copy of all listener keys
    HasKey(key string) bool                   // O(1) key existence check
    Metadata(key string) *ListenerMetadata    // Get listener info (nil if not found)
}

// Error handling behavior by signal type
// - AsyncSignal: Errors are captured and logged/counted but don't block emission
//                Error available via Metadata() or metrics when enabled
// - SyncSignal:  Errors propagate through TryEmit() (existing behavior)

// ListenerMetadata provides listener information
type ListenerMetadata struct {
    Key         string        // Listener key (empty if no key)
    AddedAt     time.Time     // When listener was added
    CallCount   int64         // Number of times invoked (if metrics enabled)
    ErrorCount  int64         // Number of errors returned (if metrics enabled)
    LastError   error         // Most recent error (if metrics enabled)
    IsOnce      bool          // True if added via AddOnce*
    IsErrorAware bool         // True if added via *WithErr
    LastCalled  time.Time     // Last invocation time (if metrics enabled)
}
```

**Implementation Notes:**

- **AsyncSignal with errors**: When `AddListenerWithErr` is used on AsyncSignal:
  ```go
  asyncSig := signals.New[Event]()
  asyncSig.AddListenerWithErr(func(ctx context.Context, e Event) error {
      if err := validate(e); err != nil {
          return err  // Error captured, logged, but doesn't block
      }
      return nil
  }, "validator")

  // Later, check if listener had errors
  if meta := asyncSig.Metadata("validator"); meta != nil && meta.ErrorCount > 0 {
      log.Warnf("Validator had %d errors, last: %v", meta.ErrorCount, meta.LastError)
  }
  ```

- **SyncSignal behavior unchanged**: Existing TryEmit() error propagation maintained
  ```go
  syncSig := signals.NewSync[Event]()
  syncSig.AddListenerWithErr(validator, "validator")

  if err := syncSig.TryEmit(ctx, event); err != nil {
      // Errors still propagate immediately
  }
  ```

**Success Criteria:**
- `AddListenerWithErr` available on both AsyncSignal and SyncSignal
- AsyncSignal captures errors without blocking (async error tracking)
- SyncSignal maintains existing error propagation behavior
- One-time listeners automatically removed after single emit
- `Keys()` returns snapshot safe for concurrent iteration
- `HasKey()` provides O(1) lookup performance
- `Metadata()` returns rich listener information when metrics enabled
- All new APIs covered by tests
- Documentation includes real-world usage examples for both signal types
- Zero performance impact when features not used

---

### 4. Enterprise Observability and Metrics
**Priority:** HIGH
**Status:** Not Implemented (0%)

Add lightweight observability features for monitoring in-process signal behavior and integrating with application-level monitoring systems.

**Requirements:**

#### Core Metrics (Application-Level)
- **Rate**: Emissions/sec, listener invocations/sec (by signal type)
- **Errors**: Error count/rate, panic count/rate (by error type)
- **Duration**: Listener execution latency (min/max/avg/p95/p99)

#### Resource Metrics
- **Utilization**: Worker pool usage %, queue depth, active listeners
- **Saturation**: Queue wait time, backpressure indicators
- **Efficiency**: Allocation count, GC pressure indicators

#### Listener Lifecycle Metrics
- Signal type distribution (sync/async usage patterns)
- Listener lifecycle events (add/remove/execute counts)
- Per-signal metrics (named signals with cardinality limits)

#### Integration Points
- `MetricsCollector` interface for custom implementations
- Optional Prometheus metrics exporter (separate package/module)
- OpenTelemetry span support for local tracing within the application
- Simple metrics API for custom monitoring integrations
- Structured metric data for programmatic access

#### Developer Features
- Runtime metrics enable/disable without restart
- Metrics snapshot export for debugging
- Listener metadata query API (already in Feature #3)
- Low-overhead collection suitable for production use

#### Operational Helpers
- Simple health check API (e.g., `IsHealthy()`, `Stats()`)
- Anomaly detection hints (e.g., queue depth thresholds)
- Resource usage warnings (memory, goroutine counts)

**Success Criteria:**
- <1% CPU overhead, <5MB memory overhead when metrics enabled
- Zero overhead when metrics disabled (compile-time or runtime opt-out)
- Prometheus exporter available as optional package
- OpenTelemetry integration works for in-process tracing
- Documentation includes integration examples (Prometheus, custom collectors)
- Metrics API is simple and idiomatic (follows Go conventions)

---

### 5. Property-Based and Fuzz Testing
**Priority:** LOW
**Status:** Not Implemented (0%)

Enhance testing strategy with advanced verification techniques.

**Requirements:**
- Add property-based tests using `testing/quick` or `gopter`
- Implement fuzz testing for concurrent operations
- Test invariants:
  - Listener count always matches actual registered listeners
  - No listener called after removal
  - All listeners called exactly once per emission (or zero if removed)
  - Context cancellation always stops pending listeners
- Run in CI with race detector and memory sanitizer
- Document testing methodology

**Success Criteria:**
- Property tests cover all concurrent operations
- Fuzz tests run for minimum 1 minute in CI
- All invariants verified
- Zero race conditions detected

---

## Non-Functional Requirements

### Performance & Scalability

#### Latency Requirements
- **p50 latency**: < 5μs for single listener emit (zero allocation path)
- **p95 latency**: < 10μs for multi-listener emit (up to 100 listeners)
- **p99 latency**: < 50μs under sustained load (1000 concurrent emitters)
- **p999 latency**: < 100μs (no pathological cases)
- **Lock contention**: Zero lock waits during emission (verified via pprof)

#### Throughput Requirements
- **Single signal**: 1M+ emits/sec on 8-core CPU
- **Concurrent signals**: Linear scaling up to 10,000 active signals
- **Listener scalability**: No degradation up to 1,000 listeners per signal
- **Worker pool**: Handle 100,000+ async tasks/sec

#### Resource Efficiency
- **Memory overhead**: <100 bytes per listener
- **Allocation rate**: <100 allocs/sec in steady state
- **GC impact**: <1% GC time under typical load
- **CPU efficiency**: >95% useful work (not locking/scheduling)
- **Metrics overhead**: <1% CPU, <5MB memory when enabled

### Reliability & Availability

#### Testing Requirements
- **Code coverage**: >95% for all new code, maintain existing coverage
- **Race detection**: 100% pass rate under race detector
- **Stress testing**: 1 hour sustained load at 10x normal capacity
- **Chaos testing**: Resilience to random goroutine kills, network issues
- **Property tests**: All concurrent operations verified with property-based tests
- **Fuzz testing**: 24-hour fuzz runs with zero crashes

#### Fault Tolerance
- **Panic isolation**: Listener panics never crash other listeners or system
- **Error propagation**: All errors properly captured and reported
- **Resource leaks**: Zero goroutine/memory leaks (verified with leak detector)
- **Graceful degradation**: System remains operational even when individual listeners fail
- **Circuit breaker**: Failing listeners can be automatically disabled (optional)

#### Data Integrity
- **Concurrency safety**: Zero data races under all conditions
- **Ordering guarantees**: Documented and verified ordering semantics
- **Memory consistency**: All operations use proper memory barriers
- **No lost signals**: All registered listeners receive all emitted signals (unless removed)

### Compatibility & Portability

#### API Compatibility
- **Backward compatibility**: 100% compatibility with v1.3.x
- **Semantic versioning**: Strict adherence to semver 2.0
- **Deprecation policy**: 6-month notice for any deprecations
- **Feature flags**: All new features opt-in with sensible defaults

#### Platform Support
- **Go versions**: 1.18+ (test on 1.18, 1.20, 1.21, latest)
- **Operating systems**: Linux, macOS, Windows (amd64, arm64)
- **Container environments**: Docker, Kubernetes validated
- **Cloud platforms**: AWS, GCP, Azure tested

#### Dependency Management
- **Zero external dependencies**: Core library has no dependencies
- **Optional dependencies**: Metrics integrations are opt-in modules
- **Go modules**: Proper module versioning and minimal version selection

### Documentation & Support

#### API Documentation
- **Godoc coverage**: 100% of public APIs documented
- **Code examples**: Every public function has usage example
- **Error documentation**: All error conditions documented
- **Performance notes**: Document performance characteristics of each API

#### Guides & Tutorials
- **Getting started**: 5-minute quickstart guide
- **Migration guide**: Step-by-step upgrade from v1.3.x
- **Performance tuning**: Comprehensive guide for production optimization
- **Troubleshooting**: Common issues and solutions
- **Best practices**: Patterns and anti-patterns

#### Enterprise Documentation
- **Architecture decision records**: Documented rationale for design choices
- **SLO guidelines**: How to set appropriate SLOs using this library
- **Runbooks**: Operational procedures for common scenarios
- **Capacity planning**: Guidelines for sizing worker pools, memory
- **Disaster recovery**: Handling degraded performance, failures

#### Examples & References
- **Production examples**: Real-world usage patterns
- **Benchmark suite**: Reproducible performance benchmarks
- **Reference implementations**: Complete applications using the library
- **Integration examples**: Prometheus, OpenTelemetry, logging integrations

### Security & Compliance

#### Security Requirements
- **No data races**: Verified by race detector and static analysis
- **Resource exhaustion**: Protection against memory/goroutine leaks
- **Input validation**: All public APIs validate inputs
- **Secure defaults**: Minimal attack surface in default configuration
- **No unsafe code**: Avoid `unsafe` package unless absolutely necessary

#### Audit & Compliance
- **Audit logging**: All metric collection and configuration changes logged
- **Deterministic behavior**: Reproducible behavior for compliance testing
- **Versioned artifacts**: All releases signed and checksummed
- **SBOM generation**: Software Bill of Materials for supply chain security
- **License compliance**: Apache 2.0, no GPL/LGPL dependencies

#### Privacy
- **No telemetry**: Zero phone-home, no data collection without explicit opt-in
- **PII handling**: Guidelines for avoiding PII in signals/metrics
- **Data retention**: Metrics retention policies documented

### Operational Excellence

#### Observability
- **Instrumentation**: Complete metrics coverage of all operations
- **Structured logging**: JSON logging with correlation IDs
- **Distributed tracing**: OpenTelemetry span propagation
- **Health checks**: Liveness and readiness probes
- **Debug endpoints**: Runtime introspection capabilities (with auth)

#### Deployment
- **Zero-downtime updates**: Library updates don't require restarts
- **Feature flags**: Runtime feature toggle support
- **Configuration reload**: Hot reload of configuration changes
- **Gradual rollout**: Support for canary deployments

#### Monitoring & Alerting
- **SLI tracking**: Built-in SLI calculation
- **Alert rules**: Production-ready alert definitions
- **Dashboards**: Reference Grafana dashboards
- **Anomaly detection**: Statistical baseline and deviation tracking

---

## Out of Scope for v1.4

The following items from the enhancements list are deferred to future versions:

- **Formal Verification:** Requires specialized tools and expertise (v1.5+)
- **Continuous CPU Profiling:** CI infrastructure not ready (v1.5+)
- **Advanced Dynamic Pool Scaling:** Complex heuristics need more research (v1.6+)

---

## Migration Path from v1.3.x

All v1.3.x code will continue to work without changes. New features are opt-in:

```go
// Existing code - no changes needed
sig := signals.NewSignal[string]()

// New opt-in features
sig := signals.NewSignal[string](signals.SignalOptions{
    WorkerPoolSize: 100,  // New option
})

// New APIs - concise and Go-idiomatic
sig.AddOnce(listener)       // One-time listener
sig.AddOnceWithKey(listener, "once-key")  // One-time with key
keys := sig.Keys()          // Get all keys
if sig.HasKey("my-key") {   // Check key existence
    meta := sig.Metadata("my-key")  // Get listener metadata
}
```

---

## Success Metrics

### Technical Performance Metrics

#### Performance Targets (Measured via Benchmarks)
- **Latency Improvement**: 50%+ reduction in p99 latency vs v1.3 (target: <10μs)
- **Throughput**: 1M+ emits/sec single-threaded, 10M+ multi-threaded
- **Scalability**: Linear scaling to 10,000 concurrent emitters (R² > 0.95)
- **Memory Efficiency**: Zero allocations in fast path, <100 allocs/sec steady state
- **Contention**: Zero lock contention during emission (pprof block profile)

#### Quality Metrics
- **Test Coverage**: Maintain >95% line coverage, >90% branch coverage
- **Race Detection**: 100% pass rate with `-race` flag over 1000+ test runs
- **Fuzz Testing**: 24-hour fuzz runs with zero crashes or hangs
- **Static Analysis**: Zero critical findings from `go vet`, `staticcheck`, `gosec`
- **Regression Tests**: All v1.3 benchmarks maintain or improve performance

### Enterprise Adoption Metrics

#### Production Deployment (6-Month Targets)
- **Enterprise Deployments**: 5+ companies in production
- **Industry Diversity**: Adoption in 3+ industries (finance, healthcare, tech, etc.)
- **Scale Validation**: Proven at 100,000+ signals/sec in production
- **High-Availability**: Used in systems with 99.99%+ uptime SLAs
- **Geographic Distribution**: Production use in 3+ geographic regions

#### Community & Support Metrics
- **GitHub Stars**: 100+ stars (indicate developer interest)
- **Issue Resolution**: <48hr first response, <1 week median close time
- **Documentation Quality**: <5% of issues relate to documentation gaps
- **Community Contributions**: 10+ external contributors
- **Stack Overflow**: Active Q&A presence with accepted answers

### Business Impact Metrics

#### Developer Productivity
- **Time to First Signal**: <5 minutes from install to working signal
- **Migration Effort**: <1 day to migrate typical v1.3 application
- **Debugging Time**: 30% reduction in time to diagnose signal-related issues
- **Boilerplate Reduction**: 20% less code for common patterns (one-time listeners, etc.)

#### Operational Efficiency
- **MTTR Improvement**: 50% faster incident resolution with metrics/observability
- **Monitoring Setup**: <1 hour to set up production monitoring
- **Alert Accuracy**: <5% false positive rate on recommended alerts
- **Resource Optimization**: 10%+ reduction in CPU/memory vs alternative solutions

### Compliance & Governance Metrics

#### Documentation Completeness
- **API Documentation**: 100% godoc coverage for public APIs
- **Code Examples**: 100% of public APIs have runnable examples
- **Enterprise Guides**: Complete guides for migration, tuning, troubleshooting
- **Runbooks**: Documented procedures for 10+ common operational scenarios

#### Security & Compliance
- **Vulnerability Scan**: Zero high/critical CVEs in dependencies
- **License Compliance**: 100% Apache 2.0 compatible dependencies
- **SBOM**: Software Bill of Materials generated and published
- **Security Response**: <24hr acknowledgment for security issues

### Release Quality Gates

#### Pre-Release Criteria (Must Pass All)
- ✅ All automated tests pass (unit, integration, race, fuzz)
- ✅ Benchmarks show ≥0% regression on all metrics
- ✅ Documentation review completed (technical writer approval)
- ✅ Security scan passes (no high/critical findings)
- ✅ Breaking change analysis completed (none allowed)
- ✅ Migration guide tested by external beta users
- ✅ Performance validated on 3+ platforms (Linux, macOS, Windows)
- ✅ Load testing completed (1 hour at 10x capacity)
- ✅ Metrics/observability validated in staging environment
- ✅ Release notes reviewed and approved

#### Post-Release Success Criteria (90 Days)
- ✅ Zero critical bugs reported
- ✅ <3 high-severity bugs (all resolved within 1 week)
- ✅ >80% positive feedback from enterprise users
- ✅ 3+ production deployments in regulated industries
- ✅ Performance targets validated in production environments
- ✅ Documentation issues <10% of total issues filed

### Long-Term Success Indicators (12 Months)

- **Market Position**: Recognized as go-to signals library for enterprise Go
- **Production Scale**: Supporting systems processing >1B signals/day
- **Enterprise Trust**: Used by Fortune 500 companies in production
- **Ecosystem Growth**: 3+ third-party integrations/plugins
- **Stability**: v1.4.x releases are maintenance-only (no major bug fixes needed)
- **Performance Leadership**: Fastest open-source signals library for Go (benchmarked)
