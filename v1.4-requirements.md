# Version 1.4 Requirements

## Objectives

Version 1.4 is a **performance and correctness release** that upgrades the signals library to lock-free architecture and validates correctness through rigorous testing.

### Primary Goals

1. **Lock-Free Architecture**: Replace `sync.RWMutex` with lock-free copy-on-write using `atomic.Value` to eliminate lock contention during concurrent signal emission.

2. **Verified Correctness**: Add property-based and fuzz testing to prove thread-safety, eliminate race conditions, and ensure correct concurrent behavior.

3. **API Improvements**: Add one-time listeners (AddOnce), listener introspection (Keys, HasKey, Metadata), and worker pool configuration.

4. **Basic Observability**: Add simple metrics (Stats()) to help debug signal behavior. Optional Prometheus exporter package.

5. **Production Ready**: Comprehensive benchmarks, documentation, and migration guides for production use.

### Target Outcomes

#### Performance Goals
- **Lock-free reads**: Eliminate RWMutex contention during Emit() operations
- **Better concurrent throughput**: 20-50% improvement in multi-core benchmarks vs current RWMutex implementation
- **Zero allocations**: Maintain zero allocations in fast path (single listener)
- **Linear scaling**: Demonstrate scaling to 100+ concurrent emitters

#### Correctness Goals
- **No race conditions**: 100% pass with -race detector in all scenarios
- **Verified concurrency**: Property-based tests validate concurrent operations
- **No resource leaks**: Goroutine and memory leak tests pass
- **Panic isolation**: Listener failures never crash other listeners

#### Usability Goals
- **Simpler API**: AddOnce(), Keys(), HasKey(), Metadata() for common needs
- **Better errors**: AddListenerWithErr works on both sync and async signals
- **Easy debugging**: Basic metrics help identify slow/failing listeners

#### Quality Goals
- **High coverage**: >95% line coverage maintained
- **Backward compatible**: All v1.3.x code works unchanged
- **Well documented**: Examples for every feature, concurrent usage patterns documented

### What's New in v1.4

**Lock-Free Performance:**
- Eliminate RWMutex, upgrade to atomic copy-on-write architecture
- Zero lock contention during concurrent signal emission
- 20-50% performance improvement in concurrent scenarios

**Verified Correctness:**
- Property-based testing validates lock-free concurrent invariants
- Fuzz testing catches edge cases
- Comprehensive race detection and stress testing

**API Improvements:**
- One-time listeners: `AddOnce()`, `AddOnceWithKey()`
- Listener introspection: `Keys()`, `HasKey()`, `Metadata()`
- Worker pool configuration: `SignalOptions.WorkerPoolSize`

**Note:** Metrics/observability features have minimal scope in v1.4 or may be deferred to v1.5.

**Future versions:** See [v1.5-plus.requirements.md](v1.5-plus.requirements.md) and [v1.6-requirements.md](v1.6-requirements.md) for future ideas.

---

## Functional Requirements

### 1. Lock-Free Architecture Implementation
**Priority:** HIGH
**Status:** Not Implemented (0%)

**Current State:** Using `sync.RWMutex` for listener management
**Target:** Lock-free copy-on-write using `atomic.Value`

Replace RWMutex with atomic copy-on-write to eliminate lock contention during signal emission.

**Requirements:**
- Replace `sync.RWMutex` with `atomic.Value` for listener storage
- Implement copy-on-write for AddListener/RemoveListener operations
- Lock-free reads for Emit() operations (zero contention)
- Maintain backward compatibility with existing API
- Comprehensive concurrent correctness tests
- Benchmark vs current RWMutex implementation

**Success Criteria:**
- Zero lock contention during Emit() (verified via pprof)
- 20-50% performance improvement in concurrent benchmarks
- 100% pass rate with race detector
- All existing tests pass
- Linear scaling demonstrated in benchmarks

---

### 2. Configurable Worker Pool
**Priority:** MEDIUM
**Status:** Not Implemented (0%)

**Current State:** `SignalOptions` exists with `InitialCapacity` and `GrowthFunc`
**Target:** Add `WorkerPoolSize` configuration for AsyncSignal

Extend SignalOptions to allow configuring worker pool size for async signals.

**Requirements:**
```go
type SignalOptions struct {
    InitialCapacity int  // Already exists
    GrowthFunc func(int) int  // Already exists
    WorkerPoolSize int  // NEW: for AsyncSignal worker pool
}
```
- Add `WorkerPoolSize` field to `SignalOptions`
- Apply to AsyncSignal worker pool configuration
- Document recommended pool sizes
- Default: `2 * runtime.NumCPU()` (existing behavior)

**Success Criteria:**
- Users can set custom worker pool size
- Pool size configuration documented with guidelines
- Benchmarks show appropriate pool sizing impact

---

### 3. API Ergonomics Enhancements
**Priority:** MEDIUM
**Status:** Partially Implemented (30%)

**Already Implemented:**
- ✅ `AddListener(listener, key...)` - Working on both sync and async
- ✅ `RemoveListener(key)` - Working on both sync and async
- ✅ `Len()` and `IsEmpty()` - Working on both sync and async

**Partially Implemented:**
- ⚠️ `AddListenerWithErr(listener, key...)` - Only on BaseSignal/SyncSignal, **needs to be added to Signal interface and AsyncSignal**

**Not Implemented:**
- ❌ `AddOnce()` / `AddOnceWithKey()` - One-time listeners
- ❌ `Keys()` - Get all listener keys
- ❌ `HasKey(key)` - Check key existence
- ❌ `Metadata(key)` - Get listener metadata

Add missing API methods for one-time listeners and listener introspection.

**Requirements:**

#### Add AddListenerWithErr to Signal Interface
Currently `AddListenerWithErr` is only implemented on `BaseSignal` (used by SyncSignal). It needs to be:
1. Added to the base `Signal[T]` interface in `signals.go`
2. Implemented by `AsyncSignal` with async error handling semantics
3. Already works on `SyncSignal` - just needs interface promotion

```go
// In signals.go - add to Signal interface
type Signal[T any] interface {
    // ... existing methods ...

    // NEW: Error-aware listeners (both sync and async)
    AddListenerWithErr(listener func(context.Context, T) error, key ...string) int
}
```

**Behavior by Signal Type:**
- **SyncSignal**: Errors propagate through `TryEmit()` (existing behavior, already works)
- **AsyncSignal**: Errors logged/captured but don't block emission (fire-and-forget with error tracking)

#### One-Time Listeners
```go
// Auto-remove after first emission
sig.AddOnce(listener)
sig.AddOnceWithKey(listener, "once-key")
```

#### Listener Introspection
```go
// Query listener keys
keys := sig.Keys()  // []string of all keys

// Check key existence
if sig.HasKey("my-key") {
    // Key exists
}

// Get listener metadata (basic info, no metrics in v1.4)
if meta := sig.Metadata("my-key"); meta != nil {
    fmt.Printf("Listener: %s\n", meta.Key)
}
```

**API Specification:**

```go
// Signal interface in signals.go - updated
type Signal[T any] interface {
    // Existing methods
    Emit(ctx context.Context, payload T)
    AddListener(handler SignalListener[T], key ...string) int
    RemoveListener(key string) int
    Reset()
    Len() int
    IsEmpty() bool

    // NEW: Promoted from SyncSignal to base interface
    AddListenerWithErr(listener func(context.Context, T) error, key ...string) int

    // NEW: One-time listeners
    AddOnce(listener SignalListener[T]) int
    AddOnceWithKey(listener SignalListener[T], key string) int

    // NEW: Listener introspection
    Keys() []string                        // Returns copy of all listener keys
    HasKey(key string) bool                // O(1) key existence check
    Metadata(key string) *ListenerMetadata // Get listener info (nil if not found)
}

// Basic listener metadata (no metrics in v1.4)
type ListenerMetadata struct {
    Key    string // Listener key (empty if no key)
    IsOnce bool   // True if added via AddOnce*
}
```

**Implementation Notes:**

**AsyncSignal.AddListenerWithErr behavior:**
```go
// Errors are captured but don't block emission
asyncSig := signals.New[Event]()
asyncSig.AddListenerWithErr(func(ctx context.Context, e Event) error {
    if err := validate(e); err != nil {
        return err  // Error logged internally, doesn't block other listeners
    }
    return nil
}, "validator")

// Errors can be checked via Metadata (if implemented)
// Or simply logged/counted internally
```

**SyncSignal.AddListenerWithErr behavior (already works):**
```go
// Errors propagate through TryEmit
syncSig := signals.NewSync[Event]()
syncSig.AddListenerWithErr(validator, "validator")

if err := syncSig.TryEmit(ctx, event); err != nil {
    // Error from validator propagates immediately
}
```**Success Criteria:**
- `AddListenerWithErr` added to `Signal` interface in `signals.go`
- `AsyncSignal` implements `AddListenerWithErr` with async error handling
- `SyncSignal` continues to work with existing `TryEmit()` error propagation
- One-time listeners auto-remove after first emit
- `Keys()` returns snapshot safe for concurrent access
- `HasKey()` provides O(1) lookup
- `Metadata()` returns basic listener info
- All new APIs fully tested
- Zero performance impact when not used
- Documentation with examples for both sync and async error handling

---

### 4. Basic Metrics
**Priority:** LOW
**Status:** Not Implemented (0%)
**Deferred:** Most metrics functionality deferred to v1.5+

**Minimal v1.4 Scope:**
Add very basic statistics only if time permits. Focus is on performance and correctness.

**Possible Minimal API:**
```go
// Very basic stats
type SignalStats struct {
    ListenerCount int
    EmitCount     uint64  // If easy to add atomically
}

sig.Stats()  // Returns basic stats
```

**Success Criteria:**
- Zero overhead when not called
- Simple, minimal implementation
- Optional: May defer entirely to v1.5

**Note:** Prometheus exporter, detailed metrics, and observability are explicitly deferred to future versions.

---

### 5. Correctness Testing
**Priority:** HIGH
**Status:** Partially Implemented (40%)

**Already Implemented:**
- ✅ Race detector tests exist
- ✅ Concurrent benchmarks exist
- ✅ Basic concurrent add/remove/emit tests

**Not Implemented:**
- ❌ Property-based testing
- ❌ Fuzz testing
- ❌ Comprehensive concurrent stress tests

Add rigorous testing to verify the lock-free implementation's correctness.

**Requirements:**

#### Property-Based Testing (using testing/quick or gopter)
- Test invariants:
  - Listener count matches registered listeners
  - No listener called after removal
  - All listeners receive emissions (unless removed)
  - No data corruption under concurrent operations

#### Fuzz Testing (Go 1.18+ native fuzzing)
- Fuzz concurrent add/remove/emit operations
- Random delays to expose race conditions
- Edge cases: 0 listeners, 1 listener, many listeners

#### Stress Testing
- 1000+ concurrent goroutines doing add/remove/emit
- Run for extended periods (5-10 minutes)
- Monitor for goroutine leaks

**Success Criteria:**
- Property tests verify all invariants
- Fuzz tests run 5 minutes in CI with 100% pass
- Race detector passes 100%
- Zero race conditions or data corruption

---

## Non-Functional Requirements

### Performance & Scalability

#### Performance Targets
- **Lock-free implementation**: Zero lock contention during Emit() (pprof verified)
- **Concurrent improvement**: 20-50% better throughput vs current RWMutex implementation
- **Zero allocations**: Fast path (single listener) maintains zero allocations
- **Linear scaling**: Demonstrated scaling across 2, 4, 8, 16+ cores

#### Benchmarking
- Comprehensive benchmarks comparing RWMutex vs atomic.Value
- Concurrent emission benchmarks (10, 100, 1000+ goroutines)
- Scaling benchmarks across different core counts
- Real-world scenarios documented
- Before/after comparison published

### Testing & Quality

#### Correctness Testing
- **Race detection**: 100% pass with `go test -race` in all scenarios
- **Property-based tests**: Concurrent operations verified with invariants
- **Fuzz testing**: 5-10 minute fuzz runs in CI catch edge cases
- **Concurrent scenarios**: Multi-goroutine stress testing
- **Code coverage**: >95% line coverage maintained

#### Reliability
- **Panic isolation**: Listener panics don't crash other listeners or system
- **No race conditions**: Race detector passes in all concurrent tests
- **No leaks**: Goroutine and memory leak tests pass
- **Backward compatible**: All v1.3.x tests pass unchanged
- **Concurrent correctness**: All operations safe under concurrent access

### Compatibility & Portability

#### API Compatibility
- **Backward compatibility**: 100% compatibility with v1.3.x
- **Semantic versioning**: Strict adherence to semver 2.0
- **Deprecation policy**: 6-month notice for any deprecations
- **Feature flags**: All new features opt-in with sensible defaults

#### Platform Support
- **Go versions**: 1.18+ (test on 1.18, 1.20, 1.21, latest)
- **Operating systems**: Linux, macOS, Windows (amd64, arm64)
- **Container environments**: Docker, Kubernetes validated
- **Cloud platforms**: AWS, GCP, Azure tested

#### Dependency Management
- **Zero external dependencies**: Core library has no dependencies
- **Optional dependencies**: Metrics integrations are opt-in modules
- **Go modules**: Proper module versioning and minimal version selection

### Documentation

#### API Documentation
- **Godoc**: All public APIs documented with examples
- **Usage examples**: Common patterns demonstrated
- **Error handling**: Error cases documented

#### Guides
- **Getting started**: Quick introduction with examples
- **Migration guide**: How to upgrade from v1.3.x
- **Best practices**: Common patterns and anti-patterns
- **Troubleshooting**: FAQ and common issues

#### Examples
- **Basic usage**: Simple examples for each feature
- **Integration examples**: Prometheus, HTTP middleware
- **Benchmarks**: Performance benchmarks with methodology

### Code Quality

#### Safety
- **No data races**: Verified by race detector
- **No leaks**: Goroutine and memory leak tests
- **Input validation**: Public APIs validate inputs
- **Avoid unsafe**: Minimize use of `unsafe` package

#### Standards
- **Semantic versioning**: Strict semver 2.0
- **Apache 2.0 license**: Open source, no dependencies
- **No telemetry**: No data collection

#### Configuration
- **Sensible defaults**: Works well out-of-the-box
- **Runtime control**: Enable/disable metrics at runtime

---

## Out of Scope for v1.4

The following items are explicitly deferred to future versions:

### Deferred to v1.5+
- **Advanced Metrics**: Detailed metrics, histograms, latency percentiles
- **Prometheus Exporter**: Optional package for Prometheus integration
- **Dynamic Worker Pool Scaling**: Auto-scaling based on load
- **Performance Profiling**: Built-in profiling integration

### Deferred to v1.6+
- **Signal Composition**: Filtering, mapping, merging patterns
- **Listener Prioritization**: Priority levels and ordered execution
- **Backpressure**: Advanced flow control mechanisms

### Out of Scope (Core Library)
- **Distributed Signals**: Separate package if ever needed
- **Multi-datacenter**: Not applicable to in-process library
- **Network Communication**: Core is in-process only

**Rationale:** v1.4 focuses on **lock-free performance** and **concurrent correctness**. Keep scope tight to deliver a solid foundation.

---

## Migration Path from v1.3.x

All v1.3.x code continues to work without changes. New features are opt-in:

```go
// Existing v1.3 code - no changes needed
sig := signals.New[Event]()
sig.AddListener(listener, "key")
sig.Emit(ctx, event)

// NEW in v1.4: Lock-free implementation (automatic upgrade)
// Better concurrent performance, zero code changes needed

// NEW in v1.4: One-time listeners
sig.AddOnce(listener)
sig.AddOnceWithKey(listener, "once-key")

// NEW in v1.4: Listener introspection
keys := sig.Keys()
if sig.HasKey("my-key") {
    meta := sig.Metadata("my-key")
    fmt.Printf("IsOnce: %v\\n", meta.IsOnce)
}

// NEW in v1.4: Worker pool configuration
sig := signals.NewWithOptions[Event](&signals.SignalOptions{
    WorkerPoolSize: 100,  // Custom pool size
})
```

---

## Success Metrics

### Technical Metrics

#### Performance
- **Lock-free verified**: pprof shows zero RWMutex contention during Emit()
- **Throughput improvement**: 20-50% better in concurrent benchmarks vs v1.3
- **Zero allocations**: Fast path maintains zero allocations
- **Linear scaling**: Demonstrated across 2-16 cores

#### Correctness
- **Race detector**: 100% pass with `-race` in all scenarios
- **Property tests**: All concurrent invariants verified
- **Fuzz tests**: 5+ minutes continuous fuzzing, zero failures
- **No leaks**: Goroutine/memory leak tests pass

#### Quality
- **Test coverage**: >95% line coverage
- **Backward compatible**: All v1.3 tests pass
- **API complete**: AddOnce, Keys, HasKey, Metadata working
- **Documented**: Examples and migration guide complete

### Adoption (6-12 months)
- **Production usage**: Several deployments successfully running v1.4
- **Positive feedback**: Users report performance improvements
- **Active maintenance**: Issues responded to within days
- **Growing adoption**: Steady increase in usage

---
