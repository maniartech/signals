# Version 1.5 Requirements

## Overview

This document outlines **potential features** for v1.5. These are ideas that may or may not be implemented based on v1.4 feedback and actual user needs.

**Status**: All items are **exploratory** with no committed timeline or guarantee of implementation.

**Philosophy**: Only add features that solve real problems reported by v1.4 users. Don't add complexity for theoretical benefits.

**Future Roadmap:**
- **v1.6 Requirements**: See [v1.6-requirements.md](v1.6-requirements.md) for pattern libraries and testing utilities
- **Future Ideas**: See [future.md](future.md) for research areas

---

## Version 1.5 Objectives (Tentative)

Version 1.5 **might** add some quality-of-life improvements based on real production feedback from v1.4.

### Potential Goals

1. **Better Pool Configuration**: Make worker pool sizing easier (if users report difficulty)

2. **Better Metrics**: Improve metrics usefulness (if users need more than basic counters)

3. **Better Testing Tools**: Add testing helpers (if users request them)

### What We'll Actually Do

**Wait for v1.4 feedback!** Don't build features nobody asked for.

---

## Potential Features (v1.5)

**IMPORTANT**: These are **ideas only**. Actual v1.5 scope will be determined by v1.4 user feedback.

---

### 1. Pool Sizing Helper (Maybe)
**Status:** Idea
**Priority:** TBD based on user feedback

If users struggle with worker pool sizing, provide guidance.

**Possible Approaches:**
- Documentation: "How to size your worker pool" guide
- Helper function: `signals.RecommendedPoolSize()` based on CPU cores
- Runtime warning: Log if pool seems too small/large

**NOT Auto-scaling:**
- No automatic pool expansion/contraction
- No complex scaling policies
- Users set pool size, we help them choose

**Decision Criteria:**
- Do v1.4 users report pool sizing issues?
- Are default pool sizes working well?
- Is documentation sufficient?

---

### 2. Histogram Metrics (Maybe)
**Status:** Idea
**Priority:** TBD based on user feedback

If basic min/max/avg latency isn't enough, add histograms.

**Possible Addition:**
```go
stats := sig.Stats()
fmt.Printf("p50: %v, p95: %v, p99: %v\n", 
    stats.P50, stats.P95, stats.P99)
```

**NOT Time-series database:**
- No metric retention beyond current snapshot
- No querying historical data
- Use Prometheus for time-series

**Decision Criteria:**
- Are v1.4 users asking for percentiles?
- Is Prometheus integration sufficient?
- What's the memory overhead?

---

### 3. Testing Helpers (Maybe)
**Status:** Idea
**Priority:** TBD based on user feedback

If users want better testing tools, provide them.

**Possible Helpers:**
```go
// Mock signal for testing
mock := signals.NewMock[Event](t)
mock.AssertEmitted(t, 3) // Assert 3 emissions

// Record emissions for replay
recorder := signals.NewRecorder[Event]()
sig.AddListener(recorder.Record, "recorder")
// Later: replay events in tests
```

**Decision Criteria:**
- Are v1.4 users requesting testing utilities?
- What specific testing problems do they have?
- Can we keep it simple?

---

---

## Guiding Principles for v1.5

If we do a v1.5, these principles will guide it:

### 1. Listen to Users
- Build what v1.4 users actually need
- Ignore theoretical "nice to haves"
- Solve real reported problems

### 2. Keep It Simple
- No auto-scaling complexity
- No time-series database features
- No complex abstractions

### 3. Use External Tools
- Prometheus for time-series metrics
- Go's pprof for profiling
- Standard testing tools

### 4. Maintain Quality
- Backward compatible with v1.4
- Same testing standards
- Same performance standards

---

## What's Definitely OUT of Scope

### Not Happening in v1.5
- ❌ **Auto-scaling worker pools** - Too complex, users can set pool size
- ❌ **Time-series metrics storage** - Use Prometheus
- ❌ **Built-in profiling** - Use Go's pprof
- ❌ **Metric retention/queries** - Use external monitoring
- ❌ **Complex scaling policies** - YAGNI
- ❌ **7-day soak tests** - Unrealistic for OSS
- ❌ **Continuous profiling** - Use existing tools
- ❌ **Advanced aggregation** - Over-engineered

## Decision Criteria for v1.5

We'll decide whether to do v1.5 (and what to include) based on:

### User Feedback from v1.4
- Are there common pain points?
- What features are users asking for?
- What problems are they solving with workarounds?

### Practical Considerations
- Can we implement it simply?
- Does it fit the library's core mission?
- Will it maintain backward compatibility?
- Can we test it thoroughly?

### Alternatives
- Can users solve this with existing tools?
- Is this better as documentation?
- Should this be a separate package?

**Bottom Line**: Only build v1.5 if v1.4 users clearly need it.

---

## Migration Path from v1.4.x (If v1.5 Happens)

All v1.4.x code will continue to work without changes. Any new features would be opt-in:

```go
// Existing v1.4 code - no changes needed
sig := signals.NewSignal[Event]()

// Hypothetical v1.5 features (examples only)

// Maybe: histogram metrics
stats := sig.Stats()
fmt.Printf("p99: %v\n", stats.P99)

// Maybe: recommended pool size
recommended := signals.RecommendedPoolSize()
sig := signals.New[Event](signals.Options{
    WorkerPoolSize: recommended,
})

// Maybe: testing helpers
mock := signals.NewMock[Event](t)
```

---

## Next Steps

**Immediate**: Focus on v1.4 release and adoption

**After v1.4 stable (3-6 months)**:
1. Collect user feedback
2. Identify common problems
3. Evaluate if v1.5 is needed
4. If yes, scope minimal useful features
5. If no, skip to v1.6 or stay with v1.4

**Philosophy**: Don't build features for theoretical future needs. Build for actual current problems.

---

*This document is intentionally minimal and speculative. Actual v1.5 scope (if any) will be determined by real user needs.*